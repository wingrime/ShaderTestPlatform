#version 440 core
#extension GL_NV_shader_atomic_float: require 


layout (local_size_x = 64, local_size_y = 64,local_size_z = 1) in; 
// Declare the texture inputs
layout( r32f )  uniform coherent volatile image2D dstLumKey;

uniform image2D coherent volatile image2D  srcLogLum;

shared float

void main() {
	ivec2 texcoord = ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y);
/*erase before*/
	float lum = (imageLoad(dstLumKey, ivec2(gl_GlobalInvocationID.x,gl_GlobalInvocationID.y))).;

barrier();


	/* random sampling*/
  seed = hash(342141u+gl_GlobalInvocationID.x>>gl_GlobalInvocationID.x);
  /* sample random vector*/
  rnd();
  rnd();
  vec3 dir = normalize(vec3( rnd()*2.0-1.0, rnd()*2.0-1.0, rnd()*2.0-1.0));
  //
  /* uniform sampling*/
  //vec3 dir= normalize(  vec3((float(gl_GlobalInvocationID.x)-4.0)  ,(float(gl_GlobalInvocationID.y)-4.0) ,(float(gl_GlobalInvocationID.z)-4.0))  ); 
  vec3 in_color = texture(srcCube,dir).rgb;
  barrier();
  vec3 L[9];

/*
	L[0] = (0.282094791*in_color) ;
// Y-11 
	L[1]=  (0.48860251*dir.y*in_color);
// Y01
	L[2]=  (0.48860251*dir.z*in_color);
// Y11
	L[3]=  (0.48860251*dir.x*in_color);
//Y-22 
	L[4]=  (1.092548430*dir.x*dir.y*in_color); 
//Y-12
	L[5]=  (1.092548430*dir.y*dir.z*in_color);
//Y02
	L[6]=  (1.092548430*dir.z*dir.x*in_color);
//Y12
	L[7]=  (0.315391565*(3.0*dir.z*dir.z-1.0) *in_color);
//Y22
	L[8]=  (0.546274215*(dir.x*dir.y-dir.y*dir.y)*in_color);
*/


L[0] = vec3(0.282094791)*in_color ;
// Y-11 
L[1]=  vec3(0.48860251*dir.y)*in_color;
// Y01
L[2]=  vec3(0.48860251*dir.z)*in_color;
// Y11
L[3]=  vec3(0.48860251*dir.x)*in_color;
//Y-22 
L[4]=  vec3(1.092548430*dir.x*dir.y)*in_color; 
//Y-12
L[5]=  vec3(1.092548430*dir.y*dir.z)*in_color;
//Y02
L[6]=  vec3(0.315391565*(3.0*dir.z*dir.z-1.0) )*in_color;
//Y12
L[7]=  vec3(0.772744*dir.z*dir.x)*in_color;
//Y22
L[8]=  vec3(0.386372*(dir.x*dir.x-dir.y*dir.y))*in_color;

int c;
memoryBarrierImage();
for (c = 0 ; c < 9; c++) {
	//big to do HDR!
// imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY), vec4(convolve_result_r[c] *255,convolve_result_g[c] *255,convolve_result_b[c] *255,255u)  );
	imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY),   (L[c].r/dstSamplesTotal));
	//	barrier();
	imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY+1), (L[c].g/dstSamplesTotal));
	//	barrier();
	imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY+2), (L[c].b/dstSamplesTotal));
	memoryBarrierImage();
	//imageStore(dstSHBands, ivec2(c,dstSHBandY), vec4(Lgrace_R[c]));
	//imageStore(dstSHBands, ivec2(c,dstSHBandY+1), vec4(Lgrace_G[c]));
	//imageStore(dstSHBands, ivec2(c,dstSHBandY+2), vec4(Lgrace_B[c]));


	//imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY),   (Lgrace_R[c]/dstSamplesTotal));
	//	memoryBarrierImage();
	//imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY+1), (Lgrace_G[c]/dstSamplesTotal));
	//	memoryBarrierImage();
	//imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY+2), (Lgrace_B[c]/dstSamplesTotal));

	//	memoryBarrierImage();
 //imageAtomicAdd(0,0,0,0,dstSHBands, ivec2(c,dstSHBandY),  uint(convolve_result_g[c] *255));
 //imageAtomicAdd(dstSHBands, ivec2(c,dstSHBandY),  uint(convolve_result_b[c] *255));
 
//

  //acquireMutex();
// vec4 img_data = imageLoad(dstSHBands,ivec2(c,dstSHBandY));
 //
// barrier();
 
//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4(convolve_result_r[c] ,convolve_result_g[c] ,convolve_result_b[c] ,1.0) );
//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4((convolve_result_r[c]+img_data.r)/2.0 ,(convolve_result_g[c]+img_data.g)/2.0 ,(convolve_result_b[c]+img_data.b)/2.0 ,1.0) );
//memoryBarrierImage();
//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4((convolve_result_r[c]+img_data.r) ,(convolve_result_g[c]+img_data.g) ,(convolve_result_b[c]+img_data.b) ,1.0) );

//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4((Lgrace_R[c]+img_data.r)/2.0 ,(Lgrace_G[c]+img_data.g)/2.0 ,(Lgrace_B[c]+img_data.b)/2.0,1.0) );
//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4(Lgrace_R[c] ,Lgrace_G[c] ,Lgrace_B[c],1.0) );
//barrier();
//TEST
//imageStore(dstSHBands,ivec2(c,dstSHBandY),vec4(1.0,1.0,1.0,1.0) );

	}
	memoryBarrierImage();

}